import jsPDF from 'jspdf';
import PizZip from 'pizzip';

/**
 * Export utilities for generating PDF, DOCX, and TXT files from resume content
 * Provides production-ready export functionality with proper formatting and error handling
 */

export interface ExportResult {
  success: boolean;
  error?: string;
  fileName?: string;
}

/**
 * Export resume content as PDF using jsPDF
 * Creates a professionally formatted PDF with proper typography and spacing
 */
export const exportToPDF = async (content: string, fileName: string = 'resume'): Promise<ExportResult> => {
  console.log('ExportUtils: Starting PDF export');
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });
    
    // Set up document properties
    pdf.setProperties({
      title: 'Resume',
      subject: 'Professional Resume',
      author: 'ResumeZap',
      creator: 'ResumeZap AI Resume Analyzer',
    });
    
    // Configure text settings
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const maxWidth = pageWidth - (margin * 2);
    const lineHeight = 6;
    let currentY = margin;
    
    // Set font
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(11);
    
    // Split content into paragraphs and process each one
    const paragraphs = content.split('\n').filter(p => p.trim().length > 0);
    
    for (const paragraph of paragraphs) {
      // Check if we need a new page
      if (currentY > pageHeight - margin - 20) {
        pdf.addPage();
        currentY = margin;
      }
      
      // Determine if this is a heading (simple heuristic)
      const isHeading = paragraph.length < 100 && 
                       (paragraph.toUpperCase() === paragraph || 
                        paragraph.includes(':') || 
                        /^[A-Z][A-Z\s]+$/.test(paragraph.trim()));
      
      if (isHeading) {
        // Format as heading
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        currentY += 3; // Extra space before heading
      } else {
        // Format as body text
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(11);
      }
      
      // Split text to fit within page width
      const lines = pdf.splitTextToSize(paragraph, maxWidth);
      
      // Add each line
      for (const line of lines) {
        if (currentY > pageHeight - margin - 10) {
          pdf.addPage();
          currentY = margin;
        }
        
        pdf.text(line, margin, currentY);
        currentY += lineHeight;
      }
      
      // Add extra space after headings
      if (isHeading) {
        currentY += 2;
      } else {
        currentY += 1;
      }
    }
    
    // Add footer with generation info
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.setTextColor(128, 128, 128);
      
      const footerText = `Generated by ResumeZap AI - Page ${i} of ${totalPages}`;
      const footerWidth = pdf.getTextWidth(footerText);
      pdf.text(footerText, (pageWidth - footerWidth) / 2, pageHeight - 10);
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().slice(0, 10);
    const finalFileName = `${fileName}_${timestamp}.pdf`;
    
    // Save the PDF
    pdf.save(finalFileName);
    
    console.log('ExportUtils: PDF export completed successfully');
    
    return {
      success: true,
      fileName: finalFileName,
    };
  } catch (error) {
    console.error('ExportUtils: PDF export failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to export PDF',
    };
  }
};

/**
 * Export resume content as DOCX using PizZip
 * Creates a Word document with proper formatting and structure
 */
export const exportToDOCX = async (content: string, fileName: string = 'resume'): Promise<ExportResult> => {
  console.log('ExportUtils: Starting DOCX export');
  
  try {
    // For now, export as RTF format which is compatible with Word
    // RTF is simpler and doesn't require complex ZIP manipulation
    const rtfContent = convertToRTF(content);
    
    const blob = new Blob([rtfContent], { 
      type: 'application/rtf' 
    });
    
    // Create download link
    const timestamp = new Date().toISOString().slice(0, 10);
    const finalFileName = `${fileName}_${timestamp}.rtf`;
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = finalFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('ExportUtils: RTF export completed successfully');
    
    return {
      success: true,
      fileName: finalFileName,
    };
  } catch (error) {
    console.error('ExportUtils: RTF export failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to export RTF',
    };
  }
};

/**
 * Convert plain text content to RTF format
 * RTF is compatible with Microsoft Word and other word processors
 */
function convertToRTF(content: string): string {
  // RTF header
  let rtfContent = '{\\rtf1\\ansi\\deff0\\nouicompat{\\fonttbl{\\f0\\fnil\\fcharset0 Calibri;}}';
  rtfContent += '{\\*\\generator ResumeZap;}';
  rtfContent += '\\viewkind4\\uc1\\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9 ';
  
  // Process content
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    if (!trimmedLine) {
      rtfContent += '\\par ';
      continue;
    }
    
    // Escape RTF special characters
    let escapedLine = trimmedLine
      .replace(/\\/g, '\\\\')
      .replace(/{/g, '\\{')
      .replace(/}/g, '\\}');
    
    // Determine if this is a heading
    const isHeading = trimmedLine.length < 100 && 
                     (trimmedLine.toUpperCase() === trimmedLine || 
                      trimmedLine.includes(':') || 
                      /^[A-Z][A-Z\s]+$/.test(trimmedLine));
    
    if (isHeading) {
      // Format as heading (bold, larger font)
      rtfContent += `\\pard\\sa200\\sl276\\slmult1\\b\\fs26 ${escapedLine}\\b0\\fs22\\par `;
    } else {
      // Check for bullet points
      if (/^[•·▪▫‣⁃◦\-\*\+]\s/.test(trimmedLine)) {
        // Format as bullet point with indentation
        const bulletText = escapedLine.substring(2);
        rtfContent += `\\pard\\fi-360\\li720\\sa200\\sl276\\slmult1 \\bullet\\tab ${bulletText}\\par `;
      } else {
        // Regular paragraph
        rtfContent += `\\pard\\sa200\\sl276\\slmult1 ${escapedLine}\\par `;
      }
    }
  }
  
  // Add footer
  rtfContent += '\\par\\pard\\sa200\\sl276\\slmult1\\fs18\\i Generated by ResumeZap AI Resume Analyzer\\i0\\fs22\\par ';
  
  // RTF footer
  rtfContent += '}';
  
  return rtfContent;
}

/**
 * Export resume content as TXT file
 * Creates a clean text file with proper formatting
 */
export const exportToTXT = async (content: string, fileName: string = 'resume'): Promise<ExportResult> => {
  console.log('ExportUtils: Starting TXT export');
  
  try {
    // Clean and format the content
    const cleanedContent = content
      .replace(/\r\n/g, '\n') // Normalize line endings
      .replace(/\r/g, '\n') // Handle old Mac line endings
      .replace(/\n\s*\n\s*\n/g, '\n\n') // Remove excessive empty lines
      .trim();
    
    // Add header with generation info
    const timestamp = new Date().toLocaleString();
    const header = `Generated by ResumeZap AI on ${timestamp}\n${'='.repeat(50)}\n\n`;
    const finalContent = header + cleanedContent;
    
    // Create blob and download
    const blob = new Blob([finalContent], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const timestamp_short = new Date().toISOString().slice(0, 10);
    const finalFileName = `${fileName}_${timestamp_short}.txt`;
    
    const a = document.createElement('a');
    a.href = url;
    a.download = finalFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('ExportUtils: TXT export completed successfully');
    
    return {
      success: true,
      fileName: finalFileName,
    };
  } catch (error) {
    console.error('ExportUtils: TXT export failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to export TXT',
    };
  }
};

/**
 * Main export function that routes to appropriate exporter based on format
 */
export const exportResume = async (
  content: string, 
  format: 'pdf' | 'docx' | 'txt', 
  fileName: string = 'resume'
): Promise<ExportResult> => {
  console.log('ExportUtils: Starting export to', format.toUpperCase());
  
  if (!content || content.trim().length === 0) {
    return {
      success: false,
      error: 'No content to export',
    };
  }
  
  // Sanitize filename
  const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9_-]/g, '_');
  
  // Determine if this is a cover letter or resume export
  const isCoverLetter = sanitizedFileName.startsWith('Cover_Letter_');
  
  // Apply appropriate naming convention
  const finalFileName = isCoverLetter 
    ? sanitizedFileName  // Keep cover letter format as-is
    : (sanitizedFileName.startsWith('optimized_resume_') 
       ? sanitizedFileName 
       : `optimized_resume_${sanitizedFileName}`); // Apply resume prefix for resumes
  
  switch (format) {
    case 'pdf':
      return await exportToPDF(content, finalFileName);
    case 'docx':
      return await exportToDOCX(content, finalFileName);
    case 'txt':
      return await exportToTXT(content, finalFileName);
    default:
      return {
        success: false,
        error: 'Unsupported export format',
      };
  }
};