import jsPDF from 'jspdf';
import PizZip from 'pizzip';

/**
 * Export utilities for generating PDF, DOCX, and TXT files from resume content
 * Provides production-ready export functionality with proper formatting and error handling
 */

export interface ExportResult {
  success: boolean;
  error?: string;
  fileName?: string;
}

/**
 * Export resume content as PDF using jsPDF
 * Creates a professionally formatted PDF with proper typography and spacing
 */
export const exportToPDF = async (content: string, fileName: string = 'resume'): Promise<ExportResult> => {
  console.log('ExportUtils: Starting PDF export');
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });
    
    // Set up document properties
    pdf.setProperties({
      title: 'Resume',
      subject: 'Professional Resume',
      author: 'ResumeZap',
      creator: 'ResumeZap AI Resume Analyzer',
    });
    
    // Configure text settings
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const maxWidth = pageWidth - (margin * 2);
    const lineHeight = 6;
    let currentY = margin;
    
    // Set font
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(11);
    
    // Split content into paragraphs and process each one
    const paragraphs = content.split('\n').filter(p => p.trim().length > 0);
    
    for (const paragraph of paragraphs) {
      // Check if we need a new page
      if (currentY > pageHeight - margin - 20) {
        pdf.addPage();
        currentY = margin;
      }
      
      // Determine if this is a heading (simple heuristic)
      const isHeading = paragraph.length < 100 && 
                       (paragraph.toUpperCase() === paragraph || 
                        paragraph.includes(':') || 
                        /^[A-Z][A-Z\s]+$/.test(paragraph.trim()));
      
      if (isHeading) {
        // Format as heading
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        currentY += 3; // Extra space before heading
      } else {
        // Format as body text
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(11);
      }
      
      // Split text to fit within page width
      const lines = pdf.splitTextToSize(paragraph, maxWidth);
      
      // Add each line
      for (const line of lines) {
        if (currentY > pageHeight - margin - 10) {
          pdf.addPage();
          currentY = margin;
        }
        
        pdf.text(line, margin, currentY);
        currentY += lineHeight;
      }
      
      // Add extra space after headings
      if (isHeading) {
        currentY += 2;
      } else {
        currentY += 1;
      }
    }
    
    // Add footer with generation info
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.setTextColor(128, 128, 128);
      
      const footerText = `Generated by ResumeZap AI - Page ${i} of ${totalPages}`;
      const footerWidth = pdf.getTextWidth(footerText);
      pdf.text(footerText, (pageWidth - footerWidth) / 2, pageHeight - 10);
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().slice(0, 10);
    const finalFileName = `${fileName}_${timestamp}.pdf`;
    
    // Save the PDF
    pdf.save(finalFileName);
    
    console.log('ExportUtils: PDF export completed successfully');
    
    return {
      success: true,
      fileName: finalFileName,
    };
  } catch (error) {
    console.error('ExportUtils: PDF export failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to export PDF',
    };
  }
};

/**
 * Export resume content as DOCX using PizZip
 * Creates a Word document with proper formatting and structure
 */
export const exportToDOCX = async (content: string, fileName: string = 'resume'): Promise<ExportResult> => {
  console.log('ExportUtils: Starting DOCX export');
  
  try {
    // Create a basic DOCX structure using PizZip
    const zip = new PizZip();
    
    // Add required DOCX files
    
    // 1. [Content_Types].xml
    const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`;
    
    // 2. _rels/.rels
    const rels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`;
    
    // 3. word/_rels/document.xml.rels
    const documentRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>`;
    
    // 4. word/styles.xml
    const styles = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:docDefaults>
    <w:rPrDefault>
      <w:rPr>
        <w:rFonts w:ascii="Calibri" w:hAnsi="Calibri"/>
        <w:sz w:val="22"/>
      </w:rPr>
    </w:rPrDefault>
  </w:docDefaults>
  <w:style w:type="paragraph" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:pPr>
      <w:spacing w:after="200"/>
    </w:pPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading">
    <w:name w:val="Heading"/>
    <w:pPr>
      <w:spacing w:before="240" w:after="120"/>
    </w:pPr>
    <w:rPr>
      <w:b/>
      <w:sz w:val="28"/>
    </w:rPr>
  </w:style>
</w:styles>`;
    
    // 5. word/document.xml - Main content
    const escapeXml = (text: string) => {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    };
    
    // Process content into paragraphs
    const paragraphs = content.split('\n').filter(p => p.trim().length > 0);
    let documentContent = '';
    
    paragraphs.forEach(paragraph => {
      const trimmedParagraph = paragraph.trim();
      if (trimmedParagraph.length === 0) return;
      
      // Determine if this is a heading
      const isHeading = trimmedParagraph.length < 100 && 
                       (trimmedParagraph.toUpperCase() === trimmedParagraph || 
                        trimmedParagraph.includes(':') || 
                        /^[A-Z][A-Z\s]+$/.test(trimmedParagraph));
      
      const styleId = isHeading ? 'Heading' : 'Normal';
      const escapedText = escapeXml(trimmedParagraph);
      
      documentContent += `
    <w:p>
      <w:pPr>
        <w:pStyle w:val="${styleId}"/>
      </w:pPr>
      <w:r>
        <w:t>${escapedText}</w:t>
      </w:r>
    </w:p>`;
    });
    
    const document = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>${documentContent}
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/>
    </w:sectPr>
  </w:body>
</w:document>`;
    
    // Add files to ZIP
    zip.file('[Content_Types].xml', contentTypes);
    zip.folder('_rels')?.file('.rels', rels);
    zip.folder('word')?.file('document.xml', document);
    zip.folder('word')?.file('styles.xml', styles);
    zip.folder('word')?.folder('_rels')?.file('document.xml.rels', documentRels);
    
    // Generate the DOCX file
    const blob = zip.generate({ type: 'blob', mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    
    // Create download link
    const timestamp = new Date().toISOString().slice(0, 10);
    const finalFileName = `${fileName}_${timestamp}.docx`;
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = finalFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('ExportUtils: DOCX export completed successfully');
    
    return {
      success: true,
      fileName: finalFileName,
    };
  } catch (error) {
    console.error('ExportUtils: DOCX export failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to export DOCX',
    };
  }
};

/**
 * Export resume content as TXT file
 * Creates a clean text file with proper formatting
 */
export const exportToTXT = async (content: string, fileName: string = 'resume'): Promise<ExportResult> => {
  console.log('ExportUtils: Starting TXT export');
  
  try {
    // Clean and format the content
    const cleanedContent = content
      .replace(/\r\n/g, '\n') // Normalize line endings
      .replace(/\r/g, '\n') // Handle old Mac line endings
      .replace(/\n\s*\n\s*\n/g, '\n\n') // Remove excessive empty lines
      .trim();
    
    // Add header with generation info
    const timestamp = new Date().toLocaleString();
    const header = `Generated by ResumeZap AI on ${timestamp}\n${'='.repeat(50)}\n\n`;
    const finalContent = header + cleanedContent;
    
    // Create blob and download
    const blob = new Blob([finalContent], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const timestamp_short = new Date().toISOString().slice(0, 10);
    const finalFileName = `${fileName}_${timestamp_short}.txt`;
    
    const a = document.createElement('a');
    a.href = url;
    a.download = finalFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('ExportUtils: TXT export completed successfully');
    
    return {
      success: true,
      fileName: finalFileName,
    };
  } catch (error) {
    console.error('ExportUtils: TXT export failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to export TXT',
    };
  }
};

/**
 * Main export function that routes to appropriate exporter based on format
 */
export const exportResume = async (
  content: string, 
  format: 'pdf' | 'docx' | 'txt', 
  fileName: string = 'resume'
): Promise<ExportResult> => {
  console.log('ExportUtils: Starting export to', format.toUpperCase());
  
  if (!content || content.trim().length === 0) {
    return {
      success: false,
      error: 'No content to export',
    };
  }
  
  // Sanitize filename
  const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9_-]/g, '_');
  
  switch (format) {
    case 'pdf':
      return await exportToPDF(content, sanitizedFileName);
    case 'docx':
      return await exportToDOCX(content, sanitizedFileName);
    case 'txt':
      return await exportToTXT(content, sanitizedFileName);
    default:
      return {
        success: false,
        error: 'Unsupported export format',
      };
  }
};